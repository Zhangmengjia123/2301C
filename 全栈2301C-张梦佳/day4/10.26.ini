10.26


一、
ES5 函数arguments 
arguments承接所有实参

1)两个数组合并成一个数组[数组的合并]
arr.push.apply(arr,arr2)
for循环使用push【push可以用多个参数，使用apply实现】
2)[数组的克隆---浅拷贝]
3)[将伪数组转为真正的数组]
2...展开运算符(剩余参数)
【扩展运算符】可以将[数组]转换为逗号分隔的[参数序列]
rest参数必须要放到参数最后
数组与为数组的区别
3.ES6 允许给函数参数赋值初始值
1).形参初始值  具有默认值的参数，一般位置要靠后（潜规则）
2).与解构赋值结合
//4.遍历器(iterator)[迭代器、生成器、遍历器]
1)生成器函数，根据遍历器进行封装
都有next函数，每次调用都会重新生成一个生成器函数。一种接口，为各种不同的数据结构提供统一的访问机制。
2): JavaScript 原有的表示“集合”的数据结构，主要是数组 (Array )和对象 ( Object )，ES6 又添加了 Map 和 Set 。
这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，
比如数组的成员是 Map ，Map 的成员是对象。这样就需要种统一的接口机制，来处理所有不同的数据结构。
3).遍历过程
(1)创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象.
(2) 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。
(3) 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。
(4) 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。
每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。
其中，value 属性是当前成员的值， done 属性是一个布尔值，表示遍历是否结束
//5.Symbol
1)Symbol的值是唯一的，用来解决命名冲突的问题
2)值不能和其他数据进行运算
3)定义的对象属性不能使用for…循环遍历，但可以使用Reflect.ownkeys来获取对象的所有键名

//6.promise
1)概念
Promise是异步编程的一种解决方案，是一个容器，它是一个对象，
可以获取异步操作的消息，他的出现大大改善了异步编程的困境，
避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。
2)特点
1>不受外界影响；有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
2>一旦状态改变，不会再变，任何时候都可以得到这个结果；
3>Promise 对象的状态改变，只有两种可能:从pending 变为 fulfilled 和从 pending 变为 rejected 。
只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved(已定型)。
如果改变已经发生了，你再对 Promise 对象添加回调函数，
也会立即得到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
//7.出现原因
1)解决回调地狱问题
2)解决信任问题
3)解决捕获错误能力
4)解决多个任务回调后导致多件事情顺序执行，性能消耗过多
